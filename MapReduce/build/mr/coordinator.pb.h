// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: coordinator.proto
// Protobuf C++ Version: 5.26.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_coordinator_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_coordinator_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION != 5026001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_coordinator_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_coordinator_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_coordinator_2eproto;
namespace RpcModule {
class ExampleArgs;
struct ExampleArgsDefaultTypeInternal;
extern ExampleArgsDefaultTypeInternal _ExampleArgs_default_instance_;
class ExampleReply;
struct ExampleReplyDefaultTypeInternal;
extern ExampleReplyDefaultTypeInternal _ExampleReply_default_instance_;
class RegisterRequest;
struct RegisterRequestDefaultTypeInternal;
extern RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
class RegisterResponse;
struct RegisterResponseDefaultTypeInternal;
extern RegisterResponseDefaultTypeInternal _RegisterResponse_default_instance_;
class TaskRecvReply;
struct TaskRecvReplyDefaultTypeInternal;
extern TaskRecvReplyDefaultTypeInternal _TaskRecvReply_default_instance_;
class TaskResultRequest;
struct TaskResultRequestDefaultTypeInternal;
extern TaskResultRequestDefaultTypeInternal _TaskResultRequest_default_instance_;
}  // namespace RpcModule
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace RpcModule {

// ===================================================================


// -------------------------------------------------------------------

class TaskResultRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RpcModule.TaskResultRequest) */ {
 public:
  inline TaskResultRequest() : TaskResultRequest(nullptr) {}
  ~TaskResultRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TaskResultRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline TaskResultRequest(const TaskResultRequest& from) : TaskResultRequest(nullptr, from) {}
  inline TaskResultRequest(TaskResultRequest&& from) noexcept
      : TaskResultRequest(nullptr, std::move(from)) {}
  inline TaskResultRequest& operator=(const TaskResultRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskResultRequest& operator=(TaskResultRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskResultRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskResultRequest* internal_default_instance() {
    return reinterpret_cast<const TaskResultRequest*>(
        &_TaskResultRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(TaskResultRequest& a, TaskResultRequest& b) { a.Swap(&b); }
  inline void Swap(TaskResultRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskResultRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskResultRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TaskResultRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TaskResultRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TaskResultRequest& from) { TaskResultRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TaskResultRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RpcModule.TaskResultRequest"; }

 protected:
  explicit TaskResultRequest(::google::protobuf::Arena* arena);
  TaskResultRequest(::google::protobuf::Arena* arena, const TaskResultRequest& from);
  TaskResultRequest(::google::protobuf::Arena* arena, TaskResultRequest&& from) noexcept
      : TaskResultRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIpFieldNumber = 1,
    kTaskFieldNumber = 3,
    kPortFieldNumber = 2,
    kTaskIdFieldNumber = 4,
    kTaskTypeFieldNumber = 5,
  };
  // string ip = 1;
  void clear_ip() ;
  const std::string& ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip(Arg_&& arg, Args_... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* value);

  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(
      const std::string& value);
  std::string* _internal_mutable_ip();

  public:
  // string task = 3;
  void clear_task() ;
  const std::string& task() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_task(Arg_&& arg, Args_... args);
  std::string* mutable_task();
  PROTOBUF_NODISCARD std::string* release_task();
  void set_allocated_task(std::string* value);

  private:
  const std::string& _internal_task() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task(
      const std::string& value);
  std::string* _internal_mutable_task();

  public:
  // int32 port = 2;
  void clear_port() ;
  ::int32_t port() const;
  void set_port(::int32_t value);

  private:
  ::int32_t _internal_port() const;
  void _internal_set_port(::int32_t value);

  public:
  // int32 task_id = 4;
  void clear_task_id() ;
  ::int32_t task_id() const;
  void set_task_id(::int32_t value);

  private:
  ::int32_t _internal_task_id() const;
  void _internal_set_task_id(::int32_t value);

  public:
  // int32 task_type = 5;
  void clear_task_type() ;
  ::int32_t task_type() const;
  void set_task_type(::int32_t value);

  private:
  ::int32_t _internal_task_type() const;
  void _internal_set_task_type(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:RpcModule.TaskResultRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr ip_;
    ::google::protobuf::internal::ArenaStringPtr task_;
    ::int32_t port_;
    ::int32_t task_id_;
    ::int32_t task_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_coordinator_2eproto;
};
// -------------------------------------------------------------------

class TaskRecvReply final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RpcModule.TaskRecvReply) */ {
 public:
  inline TaskRecvReply() : TaskRecvReply(nullptr) {}
  ~TaskRecvReply() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TaskRecvReply(
      ::google::protobuf::internal::ConstantInitialized);

  inline TaskRecvReply(const TaskRecvReply& from) : TaskRecvReply(nullptr, from) {}
  inline TaskRecvReply(TaskRecvReply&& from) noexcept
      : TaskRecvReply(nullptr, std::move(from)) {}
  inline TaskRecvReply& operator=(const TaskRecvReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskRecvReply& operator=(TaskRecvReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskRecvReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskRecvReply* internal_default_instance() {
    return reinterpret_cast<const TaskRecvReply*>(
        &_TaskRecvReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(TaskRecvReply& a, TaskRecvReply& b) { a.Swap(&b); }
  inline void Swap(TaskRecvReply* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskRecvReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskRecvReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TaskRecvReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TaskRecvReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TaskRecvReply& from) { TaskRecvReply::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TaskRecvReply* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RpcModule.TaskRecvReply"; }

 protected:
  explicit TaskRecvReply(::google::protobuf::Arena* arena);
  TaskRecvReply(::google::protobuf::Arena* arena, const TaskRecvReply& from);
  TaskRecvReply(::google::protobuf::Arena* arena, TaskRecvReply&& from) noexcept
      : TaskRecvReply(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:RpcModule.TaskRecvReply)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_coordinator_2eproto;
};
// -------------------------------------------------------------------

class RegisterResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RpcModule.RegisterResponse) */ {
 public:
  inline RegisterResponse() : RegisterResponse(nullptr) {}
  ~RegisterResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterResponse(const RegisterResponse& from) : RegisterResponse(nullptr, from) {}
  inline RegisterResponse(RegisterResponse&& from) noexcept
      : RegisterResponse(nullptr, std::move(from)) {}
  inline RegisterResponse& operator=(const RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterResponse& operator=(RegisterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterResponse*>(
        &_RegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(RegisterResponse& a, RegisterResponse& b) { a.Swap(&b); }
  inline void Swap(RegisterResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RegisterResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterResponse& from) { RegisterResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RegisterResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RpcModule.RegisterResponse"; }

 protected:
  explicit RegisterResponse(::google::protobuf::Arena* arena);
  RegisterResponse(::google::protobuf::Arena* arena, const RegisterResponse& from);
  RegisterResponse(::google::protobuf::Arena* arena, RegisterResponse&& from) noexcept
      : RegisterResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:RpcModule.RegisterResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_coordinator_2eproto;
};
// -------------------------------------------------------------------

class RegisterRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RpcModule.RegisterRequest) */ {
 public:
  inline RegisterRequest() : RegisterRequest(nullptr) {}
  ~RegisterRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterRequest(const RegisterRequest& from) : RegisterRequest(nullptr, from) {}
  inline RegisterRequest(RegisterRequest&& from) noexcept
      : RegisterRequest(nullptr, std::move(from)) {}
  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterRequest& operator=(RegisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest*>(
        &_RegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(RegisterRequest& a, RegisterRequest& b) { a.Swap(&b); }
  inline void Swap(RegisterRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RegisterRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterRequest& from) { RegisterRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RegisterRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RpcModule.RegisterRequest"; }

 protected:
  explicit RegisterRequest(::google::protobuf::Arena* arena);
  RegisterRequest(::google::protobuf::Arena* arena, const RegisterRequest& from);
  RegisterRequest(::google::protobuf::Arena* arena, RegisterRequest&& from) noexcept
      : RegisterRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIpFieldNumber = 1,
    kTaskFieldNumber = 5,
    kTaskresuleFieldNumber = 6,
    kPortFieldNumber = 2,
    kStatusFieldNumber = 3,
    kTypeFieldNumber = 4,
    kTaskIndexFieldNumber = 7,
    kDoneFieldNumber = 8,
  };
  // string ip = 1;
  void clear_ip() ;
  const std::string& ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip(Arg_&& arg, Args_... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* value);

  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(
      const std::string& value);
  std::string* _internal_mutable_ip();

  public:
  // string task = 5;
  void clear_task() ;
  const std::string& task() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_task(Arg_&& arg, Args_... args);
  std::string* mutable_task();
  PROTOBUF_NODISCARD std::string* release_task();
  void set_allocated_task(std::string* value);

  private:
  const std::string& _internal_task() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task(
      const std::string& value);
  std::string* _internal_mutable_task();

  public:
  // string taskresule = 6;
  void clear_taskresule() ;
  const std::string& taskresule() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taskresule(Arg_&& arg, Args_... args);
  std::string* mutable_taskresule();
  PROTOBUF_NODISCARD std::string* release_taskresule();
  void set_allocated_taskresule(std::string* value);

  private:
  const std::string& _internal_taskresule() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taskresule(
      const std::string& value);
  std::string* _internal_mutable_taskresule();

  public:
  // int32 port = 2;
  void clear_port() ;
  ::int32_t port() const;
  void set_port(::int32_t value);

  private:
  ::int32_t _internal_port() const;
  void _internal_set_port(::int32_t value);

  public:
  // int32 status = 3;
  void clear_status() ;
  ::int32_t status() const;
  void set_status(::int32_t value);

  private:
  ::int32_t _internal_status() const;
  void _internal_set_status(::int32_t value);

  public:
  // int32 type = 4;
  void clear_type() ;
  ::int32_t type() const;
  void set_type(::int32_t value);

  private:
  ::int32_t _internal_type() const;
  void _internal_set_type(::int32_t value);

  public:
  // int32 TaskIndex = 7;
  void clear_taskindex() ;
  ::int32_t taskindex() const;
  void set_taskindex(::int32_t value);

  private:
  ::int32_t _internal_taskindex() const;
  void _internal_set_taskindex(::int32_t value);

  public:
  // bool Done = 8;
  void clear_done() ;
  bool done() const;
  void set_done(bool value);

  private:
  bool _internal_done() const;
  void _internal_set_done(bool value);

  public:
  // @@protoc_insertion_point(class_scope:RpcModule.RegisterRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 0,
      58, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr ip_;
    ::google::protobuf::internal::ArenaStringPtr task_;
    ::google::protobuf::internal::ArenaStringPtr taskresule_;
    ::int32_t port_;
    ::int32_t status_;
    ::int32_t type_;
    ::int32_t taskindex_;
    bool done_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_coordinator_2eproto;
};
// -------------------------------------------------------------------

class ExampleReply final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RpcModule.ExampleReply) */ {
 public:
  inline ExampleReply() : ExampleReply(nullptr) {}
  ~ExampleReply() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExampleReply(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExampleReply(const ExampleReply& from) : ExampleReply(nullptr, from) {}
  inline ExampleReply(ExampleReply&& from) noexcept
      : ExampleReply(nullptr, std::move(from)) {}
  inline ExampleReply& operator=(const ExampleReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExampleReply& operator=(ExampleReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExampleReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExampleReply* internal_default_instance() {
    return reinterpret_cast<const ExampleReply*>(
        &_ExampleReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(ExampleReply& a, ExampleReply& b) { a.Swap(&b); }
  inline void Swap(ExampleReply* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExampleReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExampleReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ExampleReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExampleReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExampleReply& from) { ExampleReply::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ExampleReply* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RpcModule.ExampleReply"; }

 protected:
  explicit ExampleReply(::google::protobuf::Arena* arena);
  ExampleReply(::google::protobuf::Arena* arena, const ExampleReply& from);
  ExampleReply(::google::protobuf::Arena* arena, ExampleReply&& from) noexcept
      : ExampleReply(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kYFieldNumber = 1,
  };
  // int32 Y = 1;
  void clear_y() ;
  ::int32_t y() const;
  void set_y(::int32_t value);

  private:
  ::int32_t _internal_y() const;
  void _internal_set_y(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:RpcModule.ExampleReply)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t y_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_coordinator_2eproto;
};
// -------------------------------------------------------------------

class ExampleArgs final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RpcModule.ExampleArgs) */ {
 public:
  inline ExampleArgs() : ExampleArgs(nullptr) {}
  ~ExampleArgs() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExampleArgs(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExampleArgs(const ExampleArgs& from) : ExampleArgs(nullptr, from) {}
  inline ExampleArgs(ExampleArgs&& from) noexcept
      : ExampleArgs(nullptr, std::move(from)) {}
  inline ExampleArgs& operator=(const ExampleArgs& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExampleArgs& operator=(ExampleArgs&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExampleArgs& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExampleArgs* internal_default_instance() {
    return reinterpret_cast<const ExampleArgs*>(
        &_ExampleArgs_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(ExampleArgs& a, ExampleArgs& b) { a.Swap(&b); }
  inline void Swap(ExampleArgs* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExampleArgs* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExampleArgs* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ExampleArgs>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExampleArgs& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExampleArgs& from) { ExampleArgs::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ExampleArgs* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RpcModule.ExampleArgs"; }

 protected:
  explicit ExampleArgs(::google::protobuf::Arena* arena);
  ExampleArgs(::google::protobuf::Arena* arena, const ExampleArgs& from);
  ExampleArgs(::google::protobuf::Arena* arena, ExampleArgs&& from) noexcept
      : ExampleArgs(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
  };
  // int32 X = 1;
  void clear_x() ;
  ::int32_t x() const;
  void set_x(::int32_t value);

  private:
  ::int32_t _internal_x() const;
  void _internal_set_x(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:RpcModule.ExampleArgs)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t x_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_coordinator_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// RegisterRequest

// string ip = 1;
inline void RegisterRequest::clear_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& RegisterRequest::ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RpcModule.RegisterRequest.ip)
  return _internal_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterRequest::set_ip(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RpcModule.RegisterRequest.ip)
}
inline std::string* RegisterRequest::mutable_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:RpcModule.RegisterRequest.ip)
  return _s;
}
inline const std::string& RegisterRequest::_internal_ip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ip_.Get();
}
inline void RegisterRequest::_internal_set_ip(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.Set(value, GetArena());
}
inline std::string* RegisterRequest::_internal_mutable_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.ip_.Mutable( GetArena());
}
inline std::string* RegisterRequest::release_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RpcModule.RegisterRequest.ip)
  return _impl_.ip_.Release();
}
inline void RegisterRequest::set_allocated_ip(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_.IsDefault()) {
          _impl_.ip_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RpcModule.RegisterRequest.ip)
}

// int32 port = 2;
inline void RegisterRequest::clear_port() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.port_ = 0;
}
inline ::int32_t RegisterRequest::port() const {
  // @@protoc_insertion_point(field_get:RpcModule.RegisterRequest.port)
  return _internal_port();
}
inline void RegisterRequest::set_port(::int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:RpcModule.RegisterRequest.port)
}
inline ::int32_t RegisterRequest::_internal_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.port_;
}
inline void RegisterRequest::_internal_set_port(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.port_ = value;
}

// int32 status = 3;
inline void RegisterRequest::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = 0;
}
inline ::int32_t RegisterRequest::status() const {
  // @@protoc_insertion_point(field_get:RpcModule.RegisterRequest.status)
  return _internal_status();
}
inline void RegisterRequest::set_status(::int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:RpcModule.RegisterRequest.status)
}
inline ::int32_t RegisterRequest::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.status_;
}
inline void RegisterRequest::_internal_set_status(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = value;
}

// int32 type = 4;
inline void RegisterRequest::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::int32_t RegisterRequest::type() const {
  // @@protoc_insertion_point(field_get:RpcModule.RegisterRequest.type)
  return _internal_type();
}
inline void RegisterRequest::set_type(::int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:RpcModule.RegisterRequest.type)
}
inline ::int32_t RegisterRequest::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_;
}
inline void RegisterRequest::_internal_set_type(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = value;
}

// string task = 5;
inline void RegisterRequest::clear_task() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.task_.ClearToEmpty();
}
inline const std::string& RegisterRequest::task() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RpcModule.RegisterRequest.task)
  return _internal_task();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterRequest::set_task(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.task_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RpcModule.RegisterRequest.task)
}
inline std::string* RegisterRequest::mutable_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:RpcModule.RegisterRequest.task)
  return _s;
}
inline const std::string& RegisterRequest::_internal_task() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.task_.Get();
}
inline void RegisterRequest::_internal_set_task(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.task_.Set(value, GetArena());
}
inline std::string* RegisterRequest::_internal_mutable_task() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.task_.Mutable( GetArena());
}
inline std::string* RegisterRequest::release_task() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RpcModule.RegisterRequest.task)
  return _impl_.task_.Release();
}
inline void RegisterRequest::set_allocated_task(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.task_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.task_.IsDefault()) {
          _impl_.task_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RpcModule.RegisterRequest.task)
}

// string taskresule = 6;
inline void RegisterRequest::clear_taskresule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.taskresule_.ClearToEmpty();
}
inline const std::string& RegisterRequest::taskresule() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RpcModule.RegisterRequest.taskresule)
  return _internal_taskresule();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterRequest::set_taskresule(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.taskresule_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RpcModule.RegisterRequest.taskresule)
}
inline std::string* RegisterRequest::mutable_taskresule() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_taskresule();
  // @@protoc_insertion_point(field_mutable:RpcModule.RegisterRequest.taskresule)
  return _s;
}
inline const std::string& RegisterRequest::_internal_taskresule() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.taskresule_.Get();
}
inline void RegisterRequest::_internal_set_taskresule(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.taskresule_.Set(value, GetArena());
}
inline std::string* RegisterRequest::_internal_mutable_taskresule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.taskresule_.Mutable( GetArena());
}
inline std::string* RegisterRequest::release_taskresule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RpcModule.RegisterRequest.taskresule)
  return _impl_.taskresule_.Release();
}
inline void RegisterRequest::set_allocated_taskresule(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.taskresule_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taskresule_.IsDefault()) {
          _impl_.taskresule_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RpcModule.RegisterRequest.taskresule)
}

// int32 TaskIndex = 7;
inline void RegisterRequest::clear_taskindex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.taskindex_ = 0;
}
inline ::int32_t RegisterRequest::taskindex() const {
  // @@protoc_insertion_point(field_get:RpcModule.RegisterRequest.TaskIndex)
  return _internal_taskindex();
}
inline void RegisterRequest::set_taskindex(::int32_t value) {
  _internal_set_taskindex(value);
  // @@protoc_insertion_point(field_set:RpcModule.RegisterRequest.TaskIndex)
}
inline ::int32_t RegisterRequest::_internal_taskindex() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.taskindex_;
}
inline void RegisterRequest::_internal_set_taskindex(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.taskindex_ = value;
}

// bool Done = 8;
inline void RegisterRequest::clear_done() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.done_ = false;
}
inline bool RegisterRequest::done() const {
  // @@protoc_insertion_point(field_get:RpcModule.RegisterRequest.Done)
  return _internal_done();
}
inline void RegisterRequest::set_done(bool value) {
  _internal_set_done(value);
  // @@protoc_insertion_point(field_set:RpcModule.RegisterRequest.Done)
}
inline bool RegisterRequest::_internal_done() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.done_;
}
inline void RegisterRequest::_internal_set_done(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.done_ = value;
}

// -------------------------------------------------------------------

// RegisterResponse

// bool success = 1;
inline void RegisterResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool RegisterResponse::success() const {
  // @@protoc_insertion_point(field_get:RpcModule.RegisterResponse.success)
  return _internal_success();
}
inline void RegisterResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:RpcModule.RegisterResponse.success)
}
inline bool RegisterResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void RegisterResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = value;
}

// -------------------------------------------------------------------

// ExampleArgs

// int32 X = 1;
inline void ExampleArgs::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline ::int32_t ExampleArgs::x() const {
  // @@protoc_insertion_point(field_get:RpcModule.ExampleArgs.X)
  return _internal_x();
}
inline void ExampleArgs::set_x(::int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:RpcModule.ExampleArgs.X)
}
inline ::int32_t ExampleArgs::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void ExampleArgs::_internal_set_x(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = value;
}

// -------------------------------------------------------------------

// ExampleReply

// int32 Y = 1;
inline void ExampleReply::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline ::int32_t ExampleReply::y() const {
  // @@protoc_insertion_point(field_get:RpcModule.ExampleReply.Y)
  return _internal_y();
}
inline void ExampleReply::set_y(::int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:RpcModule.ExampleReply.Y)
}
inline ::int32_t ExampleReply::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void ExampleReply::_internal_set_y(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// TaskResultRequest

// string ip = 1;
inline void TaskResultRequest::clear_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& TaskResultRequest::ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RpcModule.TaskResultRequest.ip)
  return _internal_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskResultRequest::set_ip(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RpcModule.TaskResultRequest.ip)
}
inline std::string* TaskResultRequest::mutable_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:RpcModule.TaskResultRequest.ip)
  return _s;
}
inline const std::string& TaskResultRequest::_internal_ip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ip_.Get();
}
inline void TaskResultRequest::_internal_set_ip(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.Set(value, GetArena());
}
inline std::string* TaskResultRequest::_internal_mutable_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.ip_.Mutable( GetArena());
}
inline std::string* TaskResultRequest::release_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RpcModule.TaskResultRequest.ip)
  return _impl_.ip_.Release();
}
inline void TaskResultRequest::set_allocated_ip(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_.IsDefault()) {
          _impl_.ip_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RpcModule.TaskResultRequest.ip)
}

// int32 port = 2;
inline void TaskResultRequest::clear_port() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.port_ = 0;
}
inline ::int32_t TaskResultRequest::port() const {
  // @@protoc_insertion_point(field_get:RpcModule.TaskResultRequest.port)
  return _internal_port();
}
inline void TaskResultRequest::set_port(::int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:RpcModule.TaskResultRequest.port)
}
inline ::int32_t TaskResultRequest::_internal_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.port_;
}
inline void TaskResultRequest::_internal_set_port(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.port_ = value;
}

// string task = 3;
inline void TaskResultRequest::clear_task() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.task_.ClearToEmpty();
}
inline const std::string& TaskResultRequest::task() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RpcModule.TaskResultRequest.task)
  return _internal_task();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskResultRequest::set_task(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.task_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RpcModule.TaskResultRequest.task)
}
inline std::string* TaskResultRequest::mutable_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:RpcModule.TaskResultRequest.task)
  return _s;
}
inline const std::string& TaskResultRequest::_internal_task() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.task_.Get();
}
inline void TaskResultRequest::_internal_set_task(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.task_.Set(value, GetArena());
}
inline std::string* TaskResultRequest::_internal_mutable_task() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.task_.Mutable( GetArena());
}
inline std::string* TaskResultRequest::release_task() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RpcModule.TaskResultRequest.task)
  return _impl_.task_.Release();
}
inline void TaskResultRequest::set_allocated_task(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.task_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.task_.IsDefault()) {
          _impl_.task_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RpcModule.TaskResultRequest.task)
}

// int32 task_id = 4;
inline void TaskResultRequest::clear_task_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.task_id_ = 0;
}
inline ::int32_t TaskResultRequest::task_id() const {
  // @@protoc_insertion_point(field_get:RpcModule.TaskResultRequest.task_id)
  return _internal_task_id();
}
inline void TaskResultRequest::set_task_id(::int32_t value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:RpcModule.TaskResultRequest.task_id)
}
inline ::int32_t TaskResultRequest::_internal_task_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.task_id_;
}
inline void TaskResultRequest::_internal_set_task_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.task_id_ = value;
}

// int32 task_type = 5;
inline void TaskResultRequest::clear_task_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.task_type_ = 0;
}
inline ::int32_t TaskResultRequest::task_type() const {
  // @@protoc_insertion_point(field_get:RpcModule.TaskResultRequest.task_type)
  return _internal_task_type();
}
inline void TaskResultRequest::set_task_type(::int32_t value) {
  _internal_set_task_type(value);
  // @@protoc_insertion_point(field_set:RpcModule.TaskResultRequest.task_type)
}
inline ::int32_t TaskResultRequest::_internal_task_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.task_type_;
}
inline void TaskResultRequest::_internal_set_task_type(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.task_type_ = value;
}

// -------------------------------------------------------------------

// TaskRecvReply

// bool success = 1;
inline void TaskRecvReply::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool TaskRecvReply::success() const {
  // @@protoc_insertion_point(field_get:RpcModule.TaskRecvReply.success)
  return _internal_success();
}
inline void TaskRecvReply::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:RpcModule.TaskRecvReply.success)
}
inline bool TaskRecvReply::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void TaskRecvReply::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace RpcModule


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_coordinator_2eproto_2epb_2eh
